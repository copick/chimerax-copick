"""Cross-platform thumbnail caching system for ChimeraX-copick."""

import hashlib
import json
import os
import platform
from pathlib import Path
from typing import Any, Dict, Optional

from Qt.QtGui import QPixmap


class ThumbnailCache:
    """Cross-platform thumbnail cache for copick runs and tomograms."""

    def __init__(self, config_path: Optional[str] = None):
        """Initialize the thumbnail cache.

        Args:
            config_path: Path to the copick config file (used for cache namespacing)
        """
        self.config_path = config_path
        self.config_hash: Optional[str] = None
        self.cache_dir: Optional[Path] = None
        self._setup_cache_directory()

    def _setup_cache_directory(self) -> None:
        """Setup the cache directory based on the platform and config."""
        # Get platform-appropriate cache directory
        if platform.system() == "Windows":
            base_cache_dir = Path(os.environ.get("LOCALAPPDATA", "")) / "ChimeraX" / "copick_thumbnails"
        elif platform.system() == "Darwin":  # macOS
            base_cache_dir = Path.home() / "Library" / "Caches" / "ChimeraX" / "copick_thumbnails"
        else:  # Linux and other Unix-like systems
            cache_home = os.environ.get("XDG_CACHE_HOME", str(Path.home() / ".cache"))
            base_cache_dir = Path(cache_home) / "ChimeraX" / "copick_thumbnails"

        if self.config_path:
            # Create hash of the config file path and content for cache namespacing
            self.config_hash = self._compute_config_hash(self.config_path)
            self.cache_dir = base_cache_dir / self.config_hash
        else:
            # Fallback to generic cache directory
            self.cache_dir = base_cache_dir / "default"

        # Create the cache directory if it doesn't exist
        self.cache_dir.mkdir(parents=True, exist_ok=True)

        # Create metadata file if it doesn't exist
        self._ensure_metadata_file()

    def _compute_config_hash(self, config_path: str) -> str:
        """Compute a hash for the config file based on path and content."""
        hasher = hashlib.sha256()

        # Include the config file path
        hasher.update(config_path.encode("utf-8"))

        # Include the config file content if it exists
        try:
            config_file = Path(config_path)
            if config_file.exists():
                with open(config_file, "rb") as f:
                    hasher.update(f.read())
        except Exception:
            # If we can't read the config file, just use the path
            pass

        return hasher.hexdigest()[:16]  # Use first 16 characters for shorter directory names

    def _ensure_metadata_file(self) -> None:
        """Ensure the cache metadata file exists."""
        metadata_file = self.cache_dir / "cache_metadata.json"
        if not metadata_file.exists():
            import time

            metadata = {
                "created_at": str(time.time()),
                "config_path": self.config_path,
                "config_hash": self.config_hash,
                "version": "1.0",
            }
            with open(metadata_file, "w") as f:
                json.dump(metadata, f, indent=2)

    def get_cache_key(
        self,
        run_name: str,
        tomogram_type: Optional[str] = None,
        voxel_spacing: Optional[float] = None,
    ) -> str:
        """Generate a cache key for a thumbnail.

        Args:
            run_name: Name of the copick run
            tomogram_type: Type of tomogram (e.g., 'wbp', 'denoised')
            voxel_spacing: Voxel spacing value

        Returns:
            Cache key string
        """
        key_parts = [run_name]
        if tomogram_type:
            key_parts.append(tomogram_type)
        if voxel_spacing:
            key_parts.append(f"vs{voxel_spacing}")

        key_string = "_".join(key_parts)
        # Hash the key to handle special characters and ensure consistent filename
        return hashlib.md5(key_string.encode("utf-8")).hexdigest()

    def get_thumbnail_path(self, cache_key: str) -> Path:
        """Get the file path for a thumbnail cache file.

        Args:
            cache_key: Cache key generated by get_cache_key()

        Returns:
            Path to the thumbnail file
        """
        return self.cache_dir / f"{cache_key}.png"

    def has_thumbnail(self, cache_key: str) -> bool:
        """Check if a thumbnail exists in the cache.

        Args:
            cache_key: Cache key generated by get_cache_key()

        Returns:
            True if thumbnail exists, False otherwise
        """
        thumbnail_path = self.get_thumbnail_path(cache_key)
        exists = thumbnail_path.exists()
        # print(f"CACHE DEBUG: Checking cache for key '{cache_key}' at {thumbnail_path} -> {'EXISTS' if exists else 'NOT FOUND'}")
        return exists

    def save_thumbnail(self, cache_key: str, pixmap: QPixmap) -> bool:
        """Save a thumbnail to the cache.

        Args:
            cache_key: Cache key generated by get_cache_key()
            pixmap: QPixmap to save

        Returns:
            True if successful, False otherwise
        """
        try:
            thumbnail_path = self.get_thumbnail_path(cache_key)
            return pixmap.save(str(thumbnail_path), "PNG")
        except Exception as e:
            print(f"Error saving thumbnail to cache: {e}")
            return False

    def load_thumbnail(self, cache_key: str) -> Optional[QPixmap]:
        """Load a thumbnail from the cache.

        Args:
            cache_key: Cache key generated by get_cache_key()

        Returns:
            QPixmap if successful, None otherwise
        """
        try:
            thumbnail_path = self.get_thumbnail_path(cache_key)
            if thumbnail_path.exists():
                pixmap = QPixmap(str(thumbnail_path))
                return pixmap if not pixmap.isNull() else None
            return None
        except Exception as e:
            print(f"Error loading thumbnail from cache: {e}")
            return None

    def clear_cache(self) -> bool:
        """Clear all thumbnails from the cache.

        Returns:
            True if successful, False otherwise
        """
        try:
            if self.cache_dir and self.cache_dir.exists():
                # Remove all PNG files (thumbnails) but keep metadata
                for thumbnail_file in self.cache_dir.glob("*.png"):
                    thumbnail_file.unlink()
                return True
            return False
        except Exception as e:
            print(f"Error clearing thumbnail cache: {e}")
            return False

    def get_cache_info(self) -> Dict[str, Any]:
        """Get information about the cache.

        Returns:
            Dictionary containing cache information
        """
        info = {
            "cache_dir": str(self.cache_dir) if self.cache_dir else None,
            "config_path": self.config_path,
            "config_hash": self.config_hash,
            "thumbnail_count": 0,
            "cache_size_mb": 0.0,
        }

        if self.cache_dir and self.cache_dir.exists():
            # Count thumbnails and calculate size
            thumbnail_files = list(self.cache_dir.glob("*.png"))
            info["thumbnail_count"] = len(thumbnail_files)

            total_size = sum(f.stat().st_size for f in thumbnail_files)
            info["cache_size_mb"] = total_size / (1024 * 1024)

        return info

    def update_config(self, config_path: str) -> None:
        """Update the cache for a new config file.

        Args:
            config_path: Path to the new config file
        """
        if config_path != self.config_path:
            self.config_path = config_path
            self._setup_cache_directory()


def get_global_cache() -> ThumbnailCache:
    """Get the global thumbnail cache instance.

    Returns:
        Global ThumbnailCache instance
    """
    if not hasattr(get_global_cache, "_instance"):
        get_global_cache._instance = ThumbnailCache()
    return get_global_cache._instance


def set_global_cache_config(config_path: str) -> None:
    """Set the config path for the global cache.

    Args:
        config_path: Path to the config file
    """
    cache = get_global_cache()
    cache.update_config(config_path)
